---
title: "DP Ordination"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
header-includes:
  - \usepackage{setspace}\doublespacing
  - \usepackage{mdframed, caption}
  - \usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
  - \usepackage{float}
  - \floatplacement{figure}{H} 
  - \usepackage{longtable}
  - \usepackage{blkarray, bigstrut}
  - \usepackage{booktabs}
  - \usepackage{multirow}
---

\newpage

```{r setup, include = F}
rm(list = ls())

library(knitr)
hook_chunk <- knitr::knit_hooks$get('chunk')
knit_hooks$set(chunk = function(x, options) {

  # add latex commands if chunk option singlespacing is TRUE
  if(isTRUE(options$singlespacing)){
    return(sprintf("\\singlespacing\n %s \n\\doublespacing", hook_chunk(x, options)))
  } else{
    return(hook_chunk(x, options))
  }
})
knitr::opts_chunk$set(
  fig.align = "center",
  tidy = T,
  singlespacing = TRUE,
  cache = FALSE,
  fig.dim = c(10,8),
  message = FALSE,
  warning = FALSE,
  comment = NA,
  echo = F
)


# packages
packs <- c("dplyr", "nimble", "htmltools", "ggplot2", "sf", "Rcpp", "RcppArmadillo", "inline", "mvtnorm", "readr", "parallel", "xtable", "rstan", "coda", "vegan", "tidyr", "gganimate", "stringr", "scatterplot3d", "plot3D", "plotly", "tidyverse")
sapply(packs, require, character.only = T)
rm(packs)

# convenience
`%notin%` <- Negate("%in%")
options(mc.cores = parallel::detectCores())
```

# Craters of the Moon analysis

```{r}
rm(list = ls())
```

## Data

````{r}
craters_data_raw <- readxl::read_excel("craters data/Sage_AnalysisMatrix_wZeros_SppCover_BareGrdCover_PlotsAsRows_CRMO_2019_20210714_1723.xlsx")
spp_codes <- paste0(
  str_sub(colnames(craters_data_raw)[6:ncol(craters_data_raw)], start = 1, end = 3),
  sapply(colnames(craters_data_raw)[6:ncol(craters_data_raw)], function(x) str_sub(x, start = str_locate(x, " ")[1] + 1, end = str_locate(x, " ")[1] + 3))
) %>% toupper
spp_codes[c(17:20, 48:49)] <- c("ARTTRID", "ARTTRIP", "ASTSPP", "ASTRSPP", "ERISPP", "ERIOSPP")
craters_data <- craters_data_raw %>%
  rename_with(
    .cols = 6:ncol(.), 
    ~spp_codes
  ) %>%
  select_if(~sum(!is.na(.)) > 0) %>%
  select_if(~all(is.numeric(.))) %>%
  select_if(colSums(.) != 0) %>%
  bind_cols(
    craters_data_raw %>% dplyr::select(Unit_Code, Loc_Name), 
    .
  )
  
craters_metadata <- readxl::read_excel("craters data/NPS-SageVegPlots-CRMO-2019-PlotAttributes.xlsx") %>%
  mutate(frame_num = sapply(strsplit(Sample_Frame, split = "_"), function(x) x[2])) %>%
  st_as_sf(
    .,                         
    coords = c("X_Coord", "Y_Coord"),
    crs = "+proj=utm +zone=12"
  ) %>%
  st_transform(., crs = 4269) 
boundaries <- read_sf("craters data/nps_boundary")
crmp_crmo <- boundaries %>% filter(UNIT_CODE %in% c("CRMP", "CRMO"))

# create response matrix
set.seed(10152021)
Y <- craters_data %>%
  mutate(
    plot = sapply(stringr::str_split(Loc_Name, pattern = "_"), function(x) x[2])
  ) %>%
  group_by(plot) %>%
  # slice_sample(n = 25) %>%
  ungroup %>%
  dplyr::select(ACHHYM:ZIGSPP) %>%
  as.matrix()
```

```{r}
ggplot() + 
  geom_sf(data = crmp_crmo, fill = NA) +
  geom_sf(
    data = craters_metadata %>%
      group_by(Sample_Frame) %>%
      slice(1) %>% 
      ungroup
  ) +
  geom_sf_text(
    data = craters_metadata %>%
      group_by(Sample_Frame) %>%
      slice(1) %>% 
      ungroup,
    aes(label = frame_num),
    size = 3,
    nudge_x = .02, nudge_y = .01
  ) +
  theme_bw()
```

## DP Ordination

```{r}
nimble_summary <- function(fit, warmup = nrow(fit[[1]])/2, thin = 1){
  # convert to coda for normal summary
  fit_warmup <- lapply(fit, function(x) x[(warmup+1):nrow(x),])
  coda_samples <- as.mcmc.list(lapply(fit_warmup, function(x) as.mcmc(
    x, start = warmup+1, end = nrow(fit), thin = thin
  )))
  
  sum <- summary(coda_samples)
  params <- dimnames(sum$statistics)[[1]]
  tmp_sum <- cbind(sum$statistics, sum$quantiles)
  
  # get r hat / n_eff
  mat <- matrix(NA, nrow = nrow(tmp_sum), ncol = 3)
  colnames(mat) <- c("Rhat", "ess_bulk", "ess_tail")
  for(i in 1:nrow(tmp_sum)){
    tmp <- sapply(fit, function(x) x[,i])
    mat[i,] <- c(Rhat(tmp), ess_bulk(tmp), ess_tail(tmp))
  }
  
  # out 
  out <- cbind(tmp_sum, mat)
  return(out)
}

fit_model <- function(seed = 1, code, data, constants, inits, niter, nchains, thin = 1){
  library(nimble)
  
  # R model
  model <- nimbleModel(code, constants, data)
  
  # C model
  model_c <- compileNimble(model)
  
  # R mcmc
  model_conf <- configureMCMC(model)
  model_conf$addMonitors(c("clus_id", "z"))

  # R mcmc
  mcmc <- buildMCMC(model_conf)
  
  # C mcmc
  mcmc_c <- compileNimble(mcmc, project = model_c)
  
  # run model
  out <- runMCMC(
    mcmc_c, 
    niter = niter, 
    nchains = nchains, 
    thin = thin, 
    init = inits,
    setSeed = seed
  )
  
  # out
  return(out)
}

ord_ls <- function(mcmc, d = 2, seed = NULL, force_K = NULL){
  # optional seed
  if(!is.null(seed)) set.seed(seed)
  
  # housekeeping
  mu <- lapply(mcmc, function(x) x[,which(grepl("mu", colnames(x)))])
  clus_id <- lapply(mcmc, function(x) x[,which(grepl("clus_id", colnames(x)))])
  other_ndx <- c(1:length(colnames(mcmc[[1]])))[-c(
    sort(c(
      which(grepl("clus_id", colnames(mcmc[[1]]))), 
      which(grepl("mu", colnames(mcmc[[1]])))
    ))
  )]
  other <- lapply(mcmc, function(x) x[,other_ndx])
  
  mu_mcmc <- do.call("rbind", mu)
  clus_mcmc <- do.call("rbind", clus_id)
  other_mcmc <- do.call("rbind", other)
  
  # helper function
  getmode <- function(v) {
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }
  
  # step 1 - determine number of non-empty cluster for each iteration
  n_clus_mcmc <- apply(clus_mcmc, 1, function(x) length(unique(x)))
  
  # step 2 - estimate the mode
  if(is.null(force_K)){
    n_clus_mode <- getmode(n_clus_mcmc)
  } else{
    n_clus_mode <- force_K
  }
  
  # step 3 - filter to iterations with n_clus_mcmc = n_clus_mode
  ## filter first
  which_equal_mode_index <- which(n_clus_mcmc == n_clus_mode)
  mu_mcmc_filtered <- mu_mcmc[which_equal_mode_index, ]
  clus_mcmc_filtered <- clus_mcmc[which_equal_mode_index, ]
  other_mcmc_filtered <- other_mcmc[which_equal_mode_index, ]
  
  ## remove empty clusters - loop
  mu_reduced <- matrix(NA, nrow = nrow(mu_mcmc_filtered), ncol = n_clus_mode * d)
  clus_reduced <- array(NA, dim = dim(clus_mcmc_filtered))
  for(i in 1:length(which_equal_mode_index)){
    clus_id_i <- sort(unique(clus_mcmc_filtered[i, ]))
    col_ndx <- which(
      stringr::str_sub(
        colnames(mu_mcmc_filtered), 
        start = stringr::str_locate(colnames(mu_mcmc_filtered), pattern = "\\[")[,1] + 1,
        end = stringr::str_locate(colnames(mu_mcmc_filtered), pattern = "\\,")[,1] - 1
      ) %in% clus_id_i
    )
    
    mu_reduced[i, ] <- mu_mcmc_filtered[i,col_ndx]
    colnames(mu_reduced) <- paste0("mu[", rep(1:n_clus_mode, d), ", ", rep(1:d, each = n_clus_mode), "]")
    clus_reduced[i, ] <- as.numeric(factor(clus_mcmc_filtered[i,]))
    colnames(clus_reduced) <- colnames(clus_mcmc_filtered)
  }
  
  # step 4 - create data matrix, cluster with k-means
  data_matrix <- matrix(
    c(mu_reduced), 
    nrow = nrow(mu_reduced) * n_clus_mode,
    ncol = d
  )
  k_means <- kmeans(data_matrix, centers = n_clus_mode)
  rho <- matrix(k_means$cluster, nrow = nrow(mu_reduced), ncol = n_clus_mode)
  
  # step 5 - check whether rho_i is a permutation of 1:n_clus_mode
  keep_ndx <- which(apply(rho, 1, function(x) all(sort(x) == 1:n_clus_mode)))
  mu_reduced <- mu_reduced[keep_ndx,]
  clus_reduced <- clus_reduced[keep_ndx,]
  other_reduced <- other_mcmc_filtered[keep_ndx, ]
  rho <- rho[keep_ndx,] %>% as.matrix(., ncol = n_clus_mode)
  
  # step 6 - relabel according to rho
  ## relabel mus first - works, but slow
  mu_relabeled <- array(NA, dim = dim(mu_reduced))
  colnames(mu_relabeled) <- colnames(mu_reduced)
  for(i in 1:nrow(mu_relabeled)){
    for(j in 1:ncol(mu_relabeled)){
      # get group id
      group_id <- stringr::str_sub(
        colnames(mu_reduced)[j], 
        start = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\[")[,1] + 1,
        end = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\,")[,1] - 1
      ) %>% as.numeric()
      
      dim_id <- stringr::str_sub(
        colnames(mu_reduced)[j], 
        start = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\,")[,1] + 1,
        end = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\]")[,1] - 1
      ) %>% as.numeric()
      
      # replace with proper value according to rho
      rho_i <- rho[i, ]
      mu_relabeled[i,j] <- mu_reduced[i, which(
        colnames(mu_reduced) == paste0("mu[", which(rho_i == group_id), ", ", dim_id, "]")
      )]
    }
  }
  
  ## relabel clus_id's
  clus_relabeled <- array(NA, dim = dim(clus_reduced))
  colnames(clus_relabeled) <- colnames(clus_reduced)
  for(i in 1:nrow(clus_relabeled)){
    rho_i <- rho[i,]
    clus_id_i <- clus_reduced[i,]
    clus_relabeled[i,] <- sapply(clus_id_i, function(x) rho_i[x])
  }
  
  out <- list(
    mu = mu_relabeled, 
    clus_id = clus_relabeled, 
    other = other_reduced,
    which_iter = which_equal_mode_index[keep_ndx]
  )
  
  return(out)
}
```

### Binary

```{r, eval = F}
library(gmp)
# probability mass function from Antoniak (1974)
antoniak <- function(k, alpha, n){
  alpha <- gmp::as.bigq(as.character(MASS::fractions(alpha)))
  
  # A.n first
  A.n <- function(x, n){
    sum(abs(gmp::Stirling1.all(n)) * x^(1:n))
  }
  
  # compute mass
  out <- as.numeric((abs(gmp::Stirling1(n, k)) * alpha^k) / A.n(alpha, n))
  return(out)
}
plot(sapply(1:10, function(x) antoniak(x, .5/10, 1518)), main = "Prior mass on number of groups for n = 1518, alpha = .5/10)
```

```{r}
any_cols <- function(df) {
  reduce(df, `|`, .init = FALSE)
}

Y <- craters_data %>%
  mutate(
    plot = sapply(stringr::str_split(Loc_Name, pattern = "_"), function(x) x[2])
  ) %>%
  group_by(plot) %>%
  # slice_sample(n = 25) %>%
  ungroup %>%
  mutate(row_id = as.character(1:n())) %>%
  dplyr::select(ACHHYM:ZIGSPP, row_id) %>%
  # convert to binary
  mutate_if(is.numeric, ~1 * (. != 0)) %>%
  # remove species that do not occur in at least 5% of sites
  select_if(function(col) is.character(col) || sum(col) >= (.05 * length(col))) %>%
  # remove rows that are all 0
  filter(any_cols(across(1:(ncol(.)-1), ~. == 1)))
row_ndx <- Y$row_id %>% as.numeric
Y <- Y %>%
  dplyr::select(-row_id) %>%
  as.matrix()

# initialize
fit_model_inits <- function(seed = 1, code, data, constants, niter, nchains, thin = 1, Y){
  library(nimble);library(vegan)
  
  # inits
  init_func <- function(Y, seed){
    set.seed(seed)
    mds <- cmdscale(vegdist(Y), eig = TRUE, k = 3)
    z_init <- (mds$points - mean(mds$points)) / sd(mds$points)
    
    kmeans <- kmeans(z_init, centers = 4)
    
    d <- 3
    nrow <- nrow(Y)
    nspecies <- ncol(Y)
    max_clus <- 50
    
    theta_init <- matrix(rnorm(d * nspecies), nspecies, d)
    diag(theta_init) <- abs(rnorm(d))
    theta_init[upper.tri(theta_init)] <- 0
    
    list(
      alpha = rnorm(nrow),
      beta = rnorm(nspecies),
      z = z_init + rnorm(nrow * d, sd = .5),
      # z = matrix(rnorm(nrow * d), nrow, d),
      theta = theta_init,
      dp_con = 1,
      clus_id = kmeans$cluster,
      mu = kmeans$centers
      # clus_id = sample(c(1:4), size = nrow, replace = T),
      # mu = matrix(d * max_clus, max_clus, d)
    )
  }
  inits <- init_func(Y = Y, seed = seed)
  
  # R model
  model <- nimbleModel(code, constants, data)
  
  # C model
  model_c <- compileNimble(model)
  
  # R mcmc
  model_conf <- configureMCMC(model)
  model_conf$addMonitors(c("clus_id", "z"))

  # R mcmc
  mcmc <- buildMCMC(model_conf)
  
  # C mcmc
  mcmc_c <- compileNimble(mcmc, project = model_c)
  
  # run model
  out <- runMCMC(
    mcmc_c, 
    niter = niter, 
    nchains = nchains, 
    thin = thin, 
    init = inits,
    setSeed = seed
  )
  
  # out
  return(out)
}

# model based
code <- nimbleCode({
  # priors
  ## site effects
  for(site in 1:nsites){
    alpha[site] ~ dnorm(0, 1)
  }
  
  ## species effects
  for(species in 1:nspecies){
    beta[species] ~ dnorm(0, 1)
  }
  
  ## z priors
  ### Dirichlet process mixture parameters
  clus_id[1:nsites] ~ dCRP(dp_con, size = nsites)
  dp_con ~ dgamma(.5, rate = 10)
  
  ### table parameters - fix covariance as identity
  for(i in 1:max_clus){
    mu[i, 1:d] ~ dmnorm(mu0[1:d], Lambda0[1:d, 1:d])
  }
  
  for(site in 1:nsites){
    # identity matrix for constraint
    z[site, 1:d] ~ dmnorm(mu[clus_id[site], 1:d], cov = S[1:d, 1:d])
  }
  
  # theta prior
  ## upper triangle = 0
  for(row in 1:(d-1)){
    for(col in (row+1):d){
      theta[row, col] <- 0
    }
  }
  
  ## diag > 0
  for(diag_element in 1:d){
    theta[diag_element, diag_element] ~ T(dnorm(0, sd = 1), 0, Inf)
  }
  
  ## lower diag of first d rows
  for(row in 2:d){
    for(col in 1:(row-1)){
      theta[row, col] ~ dnorm(0, sd = 1)
    }
  }
  
  ## all other elements
  for(row in (d+1):nspecies){
    for(col in 1:d){
      theta[row, col] ~ dnorm(0, sd = 1)
    }
  }
  
  # likelihood 
  for(site in 1:nsites){
    for(species in 1:nspecies){
      logit(pi[site, species]) <- alpha[site] + beta[species] + inprod(z[site,1:d], theta[species, 1:d])
      Y[site, species] ~ dbern(pi[site, species])
    }
  }
})

this_cluster <- makeCluster(3)
fit <- parLapply(
  cl = this_cluster,
  X = 1:3,
  fun = fit_model_inits,
  code = code,
  data = list(
    Y = Y,
    S = diag(3),
    mu0 = rep(0, 3),
    Lambda0 = diag(3)
  ),
  constants = list(
    nsites = nrow(Y),
    nspecies = ncol(Y),
    d = 3,
    max_clus = 50
  ),
  Y = Y,
  niter = 100000,
  nchains = 1,
  thin = 1
)
stopCluster(this_cluster)
saveRDS(fit, file = "rds files/crmo_bin_3d_1_3_point5_10.rds")
```

## Summarize fits

```{r}
fit <- readRDS("rds files/crmo_bin_3d_1_3_point5_10.rds")
# fit <- lapply(fit, function(x) x[(nrow(x)/2 + 1):nrow(x), ])
fit <- lapply(fit, function(x) x[(75000 + 1):nrow(x), ])
samples_relabeled <- ord_ls(mcmc = fit[c(1:3)], d = 3, seed = 12052021)

# cluster probabilities
tmp <- do.call("rbind", fit)
clus <- tmp[,grepl("clus", colnames(tmp))]
clus_num <- apply(clus, 1, function(x) length(unique(x)))
round(table(clus_num) / length(clus_num), 3)

# ord plot
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

z_mcmc <- samples_relabeled$other[,which(grepl("z", colnames(samples_relabeled$other)))]
z_tbl <- left_join(
  tibble(
    trace = c(z_mcmc),
    param = rep(colnames(z_mcmc), each = nrow(z_mcmc)),
    iter = rep(1:nrow(z_mcmc), length(colnames(z_mcmc))),
    obs_id = stringr::str_sub(
      param, 
      start = stringr::str_locate(param, pattern = "\\[")[,1] + 1,
      end = stringr::str_locate(param, pattern = "\\,")[,1] - 1
    ) %>% as.numeric(),
    dim = stringr::str_sub(
      param, 
      start = stringr::str_locate(param, pattern = "\\,")[,1] + 1,
      end = stringr::str_locate(param, pattern = "\\]")[,1] - 1
    ) %>% as.numeric()
  ),
  tibble(
    clus_id = c(samples_relabeled$clus_id),
    iter = rep(1:nrow(samples_relabeled$clus_id), length(colnames(samples_relabeled$clus_id))),
    obs_id = rep(1:ncol(samples_relabeled$clus_id), each = nrow(samples_relabeled$clus_id))
  ),
  by = c("iter", "obs_id")
)

fig <- z_tbl %>%
  group_by(obs_id, dim) %>%
  summarize(
    mean = mean(trace),
    clus = getmode(clus_id),
    clus_prob = mean(clus_id == clus)
  ) %>%
  pivot_wider(
    names_from = dim,
    values_from = mean, 
    names_prefix = "z"
  ) %>%
  ungroup() %>%
  mutate(
    clus_mode = factor(clus)
  ) %>%
  plot_ly(
    x = ~ z1, y = ~ z2, z = ~ z3, color = ~ as.factor(clus_mode)
  ) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'z1'),
                      yaxis = list(title = 'z2'),
                      zaxis = list(title = 'z3')))

hide_colorbar(fig)

# pairwise
distance <- function(x, method = "euclidean", func = func){
  if(method != "custom") {
    dist.vec <- parallelDist::parDist(x, method = method)
  } else{
    dist.vec <- parallelDist::parDist(x, method = method, func = func)
  }
  dist <- as.matrix(dist.vec)
  
  if(method == "custom") {
    dist <- dist / ncol(x)
    diag(dist) <- 1
  }
  
  return(dist)
}

matchingFuncPtr <- RcppXPtrUtils::cppXPtr(
'double customDist(const arma::mat &A, const arma::mat &B) {
  return arma::accu(A == B);
}', depends = c("RcppArmadillo"))
# distance(t(ex_matrix), method = "custom", func = matchingFuncPtr)

# data
clus_id <- samples_relabeled$clus_id
test <- distance(t(clus_id), method = "custom", func = matchingFuncPtr)

Y_df <- craters_data %>%
  mutate(
    plot = sapply(stringr::str_split(Loc_Name, pattern = "_"), function(x) x[2])
  ) %>%
  group_by(plot) %>%
  ungroup %>%
  slice(row_ndx)

df <- tibble(
  value = c(test),
  row = rep(1:1518, 1518),
  col = rep(1:1518, each = 1518)
) %>%
  left_join(
    ., 
    Y_df %>%
      dplyr::select(Loc_Name) %>%
      mutate(
        row = 1:n(),
        site = stringr::str_sub(Loc_Name, 6, 11)
      ) %>%
      dplyr::select(row, site) %>%
      group_by(site) %>%
      ungroup %>%
      rename(row_site = site),
    by = "row"
  ) %>%
  left_join(
    ., 
    Y_df %>%
      dplyr::select(Loc_Name) %>%
      mutate(
        row = 1:n(),
        site = stringr::str_sub(Loc_Name, 6, 11)
      ) %>%
      dplyr::select(row, site) %>%
      group_by(site) %>%
      ungroup %>%
      rename(col_site = site, col = row),
    by = "col"
  ) %>%
  mutate(
    row_site_num = stringr::str_sub(row_site, 5, 6),
    col_site_num = stringr::str_sub(col_site, 5, 6)
  )

test <- df %>%
  mutate(tf = ifelse(value >= 0.5, TRUE, FALSE)) %>%
  group_by(row_site_num, col_site_num) %>%
  summarize(
    mean_tf = mean(tf)
  ) %>%
  ungroup %>%
  dplyr::select(mean_tf) %>%
  unlist %>% 
  unname %>%
  matrix(., nrow = 28, ncol = 28)


# by quadrats, but labeled by site
plot_mat <- test
plot_mat[upper.tri(plot_mat)] <- NA
fields::image.plot(
  x = 
  1:nrow(plot_mat), 
  1:ncol(plot_mat), 
  plot_mat,
  col = gray.colors(n = 128, start = 1, end = 0), 
  breaks = seq(0, 1, length = 129),
  axes = F,
  xlab = "Site number",
  ylab = "Site number"
)
box()
axis(
  1, 
  at = 1:28, 
  labels =  Y_df %>%
    dplyr::select(Loc_Name) %>%
    mutate(
      row = 1:n(),
      site = stringr::str_sub(Loc_Name, 6, 11)
    ) %>%
    dplyr::select(row, site) %>%
    group_by(site) %>%
    slice(round(n()/2)) %>%
    ungroup %>%
    mutate(site_num = stringr::str_sub(site, 5, 6)) %>%
    dplyr::select(site_num) %>%
    unlist %>% unname,
  cex.axis = .75
)
axis(
  2, 
  at = 1:28, 
  labels =  Y_df %>%
    dplyr::select(Loc_Name) %>%
    mutate(
      row = 1:n(),
      site = stringr::str_sub(Loc_Name, 6, 11)
    ) %>%
    dplyr::select(row, site) %>%
    group_by(site) %>%
    slice(round(n()/2)) %>%
    ungroup %>%
    mutate(site_num = stringr::str_sub(site, 5, 6)) %>%
    dplyr::select(site_num) %>%
    unlist %>% unname,
  cex.axis = .75
)

# map with group labels
map_plot <- z_tbl %>%
  group_by(obs_id, dim) %>%
  summarize(
    mean = mean(trace),
    clus = getmode(clus_id),
    clus_prob = mean(clus_id == clus)
  ) %>%
  pivot_wider(
    names_from = dim,
    values_from = mean, 
    names_prefix = "z"
  ) %>%
  ungroup() %>%
  mutate(
    clus_mode = factor(clus)
  ) %>%
  left_join(
    ., 
    Y_df %>% dplyr::select(Unit_Code, Loc_Name) %>% mutate(obs_id = 1:n()),
    by = c("obs_id")
  ) %>%
  left_join(
    ., 
    craters_metadata %>% dplyr::select(Loc_Name, frame_num),
    by = "Loc_Name"
  ) %>%
  group_by(frame_num) %>%
  summarize(
    group = getmode(clus_mode),
    group_prop = mean(group == getmode(clus_mode))
  ) %>%
  left_join(
    craters_metadata,
    ., 
    by = "frame_num"
  ) %>%
  group_by(Sample_Frame) %>%
  slice(1) %>% 
  ungroup

map_plot %>%
  ggplot() + 
  geom_sf(data = crmp_crmo, fill = NA) +
  geom_sf(aes(col = group)) +
  geom_sf_text(
    aes(label = frame_num, col = group),
    size = 3,
    nudge_x = .01, nudge_y = .01
  ) +
  theme_bw()

# with plotly
plot_tbl <- map_plot %>%
  bind_cols(., st_coordinates(map_plot)[,1],st_coordinates(map_plot)[,2]) %>%
  rename(lat = "...18", lon = "...19")
fig <- plot_tbl %>%
  plot_ly(
    lat = ~lat,
    lon = ~lon,
    type = "scattermapbox",
    marker = list(color = "fuchsia")) %>%
  layout(mapbox= list(
    style = "white-bg",
    zoom = 9,
    center = list(lon = -113.6 ,lat = 43.28),
    layers = list(list(
      below = 'traces',
      sourcetype = "raster",
      source = list("https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}")
    ))
  ))

# with leaflet
library(leaflet)
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
factpal <- colorFactor(gg_color_hue(4), plot_tbl$group)

leaflet(plot_tbl %>% st_transform(crs = 4326)) %>% 
  addTiles() %>%
  setView(lng = -113.6 ,lat = 43.28, zoom = 9) %>%
  addWMSTiles(
    "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}",
    layers = "USGSImageryOnly"
  ) %>%
  addPolygons(
    data = crmp_crmo %>% st_transform(crs = 4326), 
    stroke = TRUE, fillOpacity = .15, smoothFactor = 0.5,
    color = "white",
    weight = 2
  ) %>%
  addCircleMarkers(
    data = plot_tbl %>% st_transform(crs = 4326),
    label = as.character(plot_tbl$frame_num),
    labelOptions = labelOptions(noHide = T,
                                direction = "right",
                                textOnly = TRUE,
                                offset = c(5, -10),
                                style = list(
                                  "color" = "yellow",
                                  "font-family" = "sanserif",
                                  "font-style" = "bold",
                                  "font-size" = "14px"
                                )),
    fillColor = ~ factpal(group),
    fill = TRUE,
    radius = 3, 
    fillOpacity = .75,
    weight = 0,
    opacity = 1
  )  %>%
  addLegend(pal = factpal, values = ~group, opacity = 1)
```

```{r}
# interpret results
Y_ <- craters_data %>%
  mutate(
    plot = sapply(stringr::str_split(Loc_Name, pattern = "_"), function(x) x[2])
  ) %>%
  group_by(plot) %>%
  # slice_sample(n = 25) %>%
  ungroup %>%
  mutate(row_id = as.character(1:n())) %>%
  dplyr::select(ACHHYM:ZIGSPP, row_id) %>%
  # convert to binary
  mutate_if(is.numeric, ~1 * (. != 0)) %>%
  # remove species that do not occur in at least 5% of sites
  select_if(function(col) is.character(col) || sum(col) >= (.05 * length(col))) %>%
  # remove rows that are all 0
  filter(any_cols(across(1:(ncol(.)-1), ~. == 1))) %>%
  bind_cols(
    craters_data %>%
      mutate(
        plot = sapply(stringr::str_split(Loc_Name, pattern = "_"), function(x) x[2])
      ) %>%
      group_by(plot) %>%
      # slice_sample(n = 25) %>%
      ungroup %>%
      mutate(row_id = as.character(1:n())) %>%
      slice(row_ndx) %>%
      select(plot),
    .
  )

# frames 1, 2, 8, 11 - group 4
## elev gradient
craters_metadata %>% 
  group_by(Sample_Frame) %>% 
  summarize(mean_elev = mean(Elevation)) %>% 
  arrange(mean_elev) %>%
  print(n = "all")

## dominant species
### ARTTRID, BROTEC, ERIOSPP
Y_ %>%
  filter(plot %in% c("CRMO01", "CRMO02", "CRMO08", "CRMO11")) %>%
  select(-plot, -row_id) %>%
  as.matrix() %>%
  colSums() / 220

# frames 19, 20, 26, 27, 32, 35
## dominant species
### BROTEC 99, POASEC 66, ALLSPP 50, SISALT 49
Y_ %>%
  filter(plot %in% c("CRMO19", "CRMO20", "CRMO26", "CRMO27", "CRMO32", "CRMO35")) %>%
  select(-plot, -row_id) %>%
  as.matrix() %>%
  colSums() / 330

# frames 25, 28
## dominant species
### poasec 76, achspp 68, phlspp 59, agospp 52
Y_ %>%
  filter(plot %in% c("CRMO25", "CRMO28")) %>%
  select(-plot, -row_id) %>%
  as.matrix() %>%
  colSums() / 110

# everything else
`%notin%` <- Negate("%in%")
Y_ %>%
  filter(plot %notin% c(
    "CRMO19", "CRMO20", "CRMO26", "CRMO27", "CRMO32", "CRMO35", "CRMO25", "CRMO28", "CRMO01", "CRMO02", "CRMO08", "CRMO11"
  )) %>%
  select(-plot, -row_id) %>%
  as.matrix() %>%
  colSums() / 858

names(craters_data_raw)
```

# Doubs River

## Data

```{r}
rm(list = ls())
nimble_summary <- function(fit, warmup = nrow(fit[[1]])/2, thin = 1){
  # convert to coda for normal summary
  fit_warmup <- lapply(fit, function(x) x[(warmup+1):nrow(x),])
  coda_samples <- as.mcmc.list(lapply(fit_warmup, function(x) as.mcmc(
    x, start = warmup+1, end = nrow(fit), thin = thin
  )))
  
  sum <- summary(coda_samples)
  params <- dimnames(sum$statistics)[[1]]
  tmp_sum <- cbind(sum$statistics, sum$quantiles)
  
  # get r hat / n_eff
  mat <- matrix(NA, nrow = nrow(tmp_sum), ncol = 3)
  colnames(mat) <- c("Rhat", "ess_bulk", "ess_tail")
  for(i in 1:nrow(tmp_sum)){
    tmp <- sapply(fit, function(x) x[,i])
    mat[i,] <- c(Rhat(tmp), ess_bulk(tmp), ess_tail(tmp))
  }
  
  # out 
  out <- cbind(tmp_sum, mat)
  return(out)
}

fit_model <- function(seed = 1, code, data, constants, inits, niter, nchains, thin = 1){
  library(nimble)
  
  # R model
  model <- nimbleModel(code, constants, data)
  
  # C model
  model_c <- compileNimble(model)
  
  # R mcmc
  model_conf <- configureMCMC(model)
  model_conf$addMonitors(c("clus_id", "z"))

  # R mcmc
  mcmc <- buildMCMC(model_conf)
  
  # C mcmc
  mcmc_c <- compileNimble(mcmc, project = model_c)
  
  # run model
  out <- runMCMC(
    mcmc_c, 
    niter = niter, 
    nchains = nchains, 
    thin = thin, 
    init = inits,
    setSeed = seed
  )
  
  # out
  return(out)
}

ord_ls <- function(mcmc, d = 2, seed = NULL, force_K = NULL){
  # optional seed
  if(!is.null(seed)) set.seed(seed)
  
  # housekeeping
  mu <- lapply(mcmc, function(x) x[,which(grepl("mu", colnames(x)))])
  clus_id <- lapply(mcmc, function(x) x[,which(grepl("clus_id", colnames(x)))])
  other_ndx <- c(1:length(colnames(mcmc[[1]])))[-c(
    sort(c(
      which(grepl("clus_id", colnames(mcmc[[1]]))), 
      which(grepl("mu", colnames(mcmc[[1]])))
    ))
  )]
  other <- lapply(mcmc, function(x) x[,other_ndx])
  
  mu_mcmc <- do.call("rbind", mu)
  clus_mcmc <- do.call("rbind", clus_id)
  other_mcmc <- do.call("rbind", other)
  
  # helper function
  getmode <- function(v) {
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }
  
  # step 1 - determine number of non-empty cluster for each iteration
  n_clus_mcmc <- apply(clus_mcmc, 1, function(x) length(unique(x)))
  
  # step 2 - estimate the mode
  if(is.null(force_K)){
    n_clus_mode <- getmode(n_clus_mcmc)
  } else{
    n_clus_mode <- force_K
  }
  
  # step 3 - filter to iterations with n_clus_mcmc = n_clus_mode
  ## filter first
  which_equal_mode_index <- which(n_clus_mcmc == n_clus_mode)
  mu_mcmc_filtered <- mu_mcmc[which_equal_mode_index, ]
  clus_mcmc_filtered <- clus_mcmc[which_equal_mode_index, ]
  other_mcmc_filtered <- other_mcmc[which_equal_mode_index, ]
  
  ## remove empty clusters - loop
  mu_reduced <- matrix(NA, nrow = nrow(mu_mcmc_filtered), ncol = n_clus_mode * d)
  clus_reduced <- array(NA, dim = dim(clus_mcmc_filtered))
  for(i in 1:length(which_equal_mode_index)){
    clus_id_i <- sort(unique(clus_mcmc_filtered[i, ]))
    col_ndx <- which(
      stringr::str_sub(
        colnames(mu_mcmc_filtered), 
        start = stringr::str_locate(colnames(mu_mcmc_filtered), pattern = "\\[")[,1] + 1,
        end = stringr::str_locate(colnames(mu_mcmc_filtered), pattern = "\\,")[,1] - 1
      ) %in% clus_id_i
    )
    
    mu_reduced[i, ] <- mu_mcmc_filtered[i,col_ndx]
    colnames(mu_reduced) <- paste0("mu[", rep(1:n_clus_mode, d), ", ", rep(1:d, each = n_clus_mode), "]")
    clus_reduced[i, ] <- as.numeric(factor(clus_mcmc_filtered[i,]))
    colnames(clus_reduced) <- colnames(clus_mcmc_filtered)
  }
  
  # step 4 - create data matrix, cluster with k-means
  data_matrix <- matrix(
    c(mu_reduced), 
    nrow = nrow(mu_reduced) * n_clus_mode,
    ncol = d
  )
  k_means <- kmeans(data_matrix, centers = n_clus_mode)
  rho <- matrix(k_means$cluster, nrow = nrow(mu_reduced), ncol = n_clus_mode)
  
  # step 5 - check whether rho_i is a permutation of 1:n_clus_mode
  keep_ndx <- which(apply(rho, 1, function(x) all(sort(x) == 1:n_clus_mode)))
  mu_reduced <- mu_reduced[keep_ndx,]
  clus_reduced <- clus_reduced[keep_ndx,]
  other_reduced <- other_mcmc_filtered[keep_ndx, ]
  rho <- rho[keep_ndx,] %>% as.matrix(., ncol = n_clus_mode)
  
  # step 6 - relabel according to rho
  ## relabel mus first - works, but slow
  mu_relabeled <- array(NA, dim = dim(mu_reduced))
  colnames(mu_relabeled) <- colnames(mu_reduced)
  for(i in 1:nrow(mu_relabeled)){
    for(j in 1:ncol(mu_relabeled)){
      # get group id
      group_id <- stringr::str_sub(
        colnames(mu_reduced)[j], 
        start = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\[")[,1] + 1,
        end = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\,")[,1] - 1
      ) %>% as.numeric()
      
      dim_id <- stringr::str_sub(
        colnames(mu_reduced)[j], 
        start = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\,")[,1] + 1,
        end = stringr::str_locate(colnames(mu_reduced)[j], pattern = "\\]")[,1] - 1
      ) %>% as.numeric()
      
      # replace with proper value according to rho
      rho_i <- rho[i, ]
      mu_relabeled[i,j] <- mu_reduced[i, which(
        colnames(mu_reduced) == paste0("mu[", which(rho_i == group_id), ", ", dim_id, "]")
      )]
    }
  }
  
  ## relabel clus_id's
  clus_relabeled <- array(NA, dim = dim(clus_reduced))
  colnames(clus_relabeled) <- colnames(clus_reduced)
  for(i in 1:nrow(clus_relabeled)){
    rho_i <- rho[i,]
    clus_id_i <- clus_reduced[i,]
    clus_relabeled[i,] <- sapply(clus_id_i, function(x) rho_i[x])
  }
  
  out <- list(
    mu = mu_relabeled, 
    clus_id = clus_relabeled, 
    other = other_reduced,
    which_iter = which_equal_mode_index[keep_ndx]
  )
  
  return(out)
}
```

```{r, eval = F}
# for geo referenced plot
library(codep)
data(Doubs, package = "codep")
doubs_plot <- Doubs.geo %>%
  as_tibble %>%
  mutate(site_num = 1:n()) %>%
  st_as_sf(coords = c("Lon", "Lat"), crs = 4326) 

doubs_plot %>%
  ggplot() +
  geom_sf() +
  theme_bw()

# leaflet
library(leaflet)
leaflet(doubs_plot %>% st_transform(crs = 4326)) %>% 
  addTiles() %>%
  setView(lng = 6.359, lat = 47.13, zoom = 9) %>%
  addWMSTiles(
    "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}",
    layers = "USGSImageryOnly"
  ) %>%
  addCircleMarkers(
    data = doubs_plot %>% st_transform(crs = 4326),
    label = as.character(doubs_plot$site_num),
    labelOptions = labelOptions(noHide = T,
                                direction = "right",
                                textOnly = TRUE,
                                offset = c(5, -10),
                                style = list(
                                  "color" = "red",
                                  "font-family" = "sanserif",
                                  "font-style" = "bold",
                                  "font-size" = "16px"
                                )),
    fill = TRUE,
    radius = 3, 
    fillOpacity = .75,
    weight = 0,
    opacity = 1
  ) 
```

```{r}
# data
library(ade4)
data(doubs)
Y <- doubs$fish[-8,] %>% as.matrix
Y[which(Y>0)] <- 1

# model based %>% 
code <- nimbleCode({
  # priors
  ## site effects
  for(site in 1:nsites){
    alpha[site] ~ dnorm(0, 1)
  }
  
  ## species effects
  for(species in 1:nspecies){
    beta[species] ~ dnorm(0, 1)
  }
  
  ## z priors
  ### Dirichlet process mixture parameters
  clus_id[1:nsites] ~ dCRP(dp_con, size = nsites)
  dp_con ~ dgamma(1, 2)
  
  ### table parameters - fix covariance as identity
  for(i in 1:max_clus){
    mu[i, 1:d] ~ dmnorm(mu0[1:d], Lambda0[1:d, 1:d])
  }
  # for(dim_ord in 1:d){
  #   mu[1, dim_ord] <- -sum(mu[2:max_clus,dim_ord])
  # }
  
  for(site in 1:nsites){
    # identity matrix for constraint
    z[site, 1:d] ~ dmnorm(mu[clus_id[site], 1:d], cov = S[1:d, 1:d])
  }
  
  # theta prior
  ## upper triangle = 0
  for(row in 1:(d-1)){
    for(col in (row+1):d){
      theta[row, col] <- 0
    }
  }
  
  ## diag > 0
  for(diag_element in 1:d){
    theta[diag_element, diag_element] ~ T(dnorm(0, sd = 1), 0, Inf)
  }
  
  ## lower diag of first d rows
  for(row in 2:d){
    for(col in 1:(row-1)){
      theta[row, col] ~ dnorm(0, sd = 1)
    }
  }
  
  ## all other elements
  for(row in (d+1):nspecies){
    for(col in 1:d){
      theta[row, col] ~ dnorm(0, sd = 1)
    }
  }
  
  # likelihood 
  for(site in 1:nsites){
    for(species in 1:nspecies){
      logit(pi[site, species]) <- alpha[site] + beta[species] + inprod(z[site,1:d], theta[species, 1:d])
      Y[site, species] ~ dpois(pi[site, species])
    }
  }
})
init_func <- function(){
  d <- 2
  nrow <- 29
  nspecies <- 27
  max_clus <- 29
  
  theta_init <- matrix(rnorm(d * nspecies), nspecies, d)
  diag(theta_init) <- abs(rnorm(d))
  theta_init[upper.tri(theta_init)] <- 0
  
  list(
    alpha = rnorm(nrow),
    beta = rnorm(nspecies),
    z = matrix(rnorm(nrow * d), nrow, d),
    theta = theta_init,
    dp_con = 1,
    clus_id = sample(c(1, 2), size = nrow, replace = T),
    mu = matrix(rnorm(d*max_clus), max_clus, d)
  )
}

this_cluster <- makeCluster(3)
fit <- parLapply(
  cl = this_cluster,
  X = 1001:1003,
  fun = fit_model,
  code = code,
  data = list(
    Y = Y,
    S = diag(2),
    mu0 = rep(0, 2),
    Lambda0 = diag(2)
  ),
  constants = list(
    nsites = nrow(Y),
    nspecies = ncol(Y),
    d = 2,
    max_clus = 29
  ),
  inits = init_func,
  niter = 100000,
  nchains = 1,
  thin = 1
)
stopCluster(this_cluster)
saveRDS(fit, file = "rds files/doubs_bin_2d.rds")
```

```{r}
library(gmp)
# probability mass function from Antoniak (1974)
antoniak <- function(k, alpha, n){
  alpha <- gmp::as.bigq(as.character(MASS::fractions(alpha)))
  
  # A.n first
  A.n <- function(x, n){
    sum(abs(gmp::Stirling1.all(n)) * x^(1:n))
  }
  
  # compute mass
  out <- as.numeric((abs(gmp::Stirling1(n, k)) * alpha^k) / A.n(alpha, n))
  return(out)
}
plot(sapply(1:10, function(x) antoniak(x, 1/10, 1518)), main = "Prior mass on number of groups for n = 29, alpha = 1/2")
```

## Summarize fits

```{r}
fit <- readRDS("rds files/doubs_bin_2d.rds")
mu <- lapply(fit, function(x) x[,which(grepl("mu", colnames(x)))])
clus_id <- lapply(fit, function(x) x[,which(grepl("clus_id", colnames(x)))])

mu_tbl <- bind_rows(
  tibble(
    trace = c(mu[[1]]),
    param = rep(colnames(mu[[1]]), each = nrow(mu[[1]])),
    iter = rep(1:nrow(mu[[1]]), length(colnames(mu[[1]]))),
    chain = 1,
    clus_id = stringr::str_sub(
      param, start = 4, end = apply(str_locate(param, pattern = ","), 1, unique)-1
    ),
    dim = stringr::str_sub(
      param, start = apply(str_locate(param, pattern = ","), 1, unique)+2, 
      end = nchar(param) - 1 
    )
  ),
  tibble(
    trace = c(mu[[2]]),
    param = rep(colnames(mu[[2]]), each = nrow(mu[[2]])),
    iter = rep(1:nrow(mu[[2]]), length(colnames(mu[[2]]))),
    chain = 2,
    clus_id = stringr::str_sub(
      param, start = 4, end = apply(str_locate(param, pattern = ","), 1, unique)-1
    ),
    dim = stringr::str_sub(
      param, start = apply(str_locate(param, pattern = ","), 1, unique)+2, 
      end = nchar(param) - 1 
    )
  ),
  tibble(
    trace = c(mu[[3]]),
    param = rep(colnames(mu[[3]]), each = nrow(mu[[3]])),
    iter = rep(1:nrow(mu[[3]]), length(colnames(mu[[3]]))),
    chain = 3,
    clus_id = stringr::str_sub(
      param, start = 4, end = apply(str_locate(param, pattern = ","), 1, unique)-1
    ),
    dim = stringr::str_sub(
      param, start = apply(str_locate(param, pattern = ","), 1, unique)+2, 
      end = nchar(param) - 1 
    )
  )
)

mu_tbl %>%
  filter(dim == 1) %>%
  ggplot(aes(x = iter, y = trace, col = clus_id)) +
  facet_wrap(~ chain, labeller = label_both) +
  geom_line() +
  theme_bw() +
  labs(
    title = bquote("Traceplot for" ~ mu[1])
  )

mu_tbl %>%
  filter(dim == 2) %>%
  ggplot(aes(x = iter, y = trace, col = clus_id)) +
  facet_wrap(~ chain, labeller = label_both) +
  geom_line() +
  theme_bw() +
  labs(
    title = bquote("Traceplot for" ~ mu[2])
  )
```

### K = 2 (modal)

```{r}
fit <- readRDS("rds files/doubs_bin_2d.rds")
fit <- lapply(fit, function(x) x[(nrow(x)/2 + 1):nrow(x), ])
samples_relabeled <- ord_ls(mcmc = fit[c(1:3)], d = 2, seed = 10182021)

mu_tbl <- tibble(
  trace = c(samples_relabeled$mu),
  param = rep(colnames(samples_relabeled$mu), each = nrow(samples_relabeled$mu)),
  iter = rep(1:nrow(samples_relabeled$mu), length(colnames(samples_relabeled$mu))),
  chain = 1,
  clus_id = stringr::str_sub(param, 4, 4), 
  dim = stringr::str_sub(param, 7, 7)
)

mu_tbl %>%
  filter(dim == 1) %>%
  ggplot(aes(x = iter, y = trace, col = clus_id)) +
  # facet_wrap(~ chain, labeller = label_both) +
  geom_line() +
  theme_bw() +
  labs(
    title = bquote("Traceplot for" ~ mu[1] * ", adjusted for label switching")
  )

mu_tbl %>%
  filter(dim == 2) %>%
  ggplot(aes(x = iter, y = trace, col = clus_id)) +
  # facet_wrap(~ chain, labeller = label_both) +
  geom_line() +
  theme_bw() +
  labs(
    title = bquote("Traceplot for" ~ mu[2] * ", adjusted for label switching")
  )
```

```{r}
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

z_mcmc <- samples_relabeled$other[,which(grepl("z", colnames(samples_relabeled$other)))]
z_tbl <- left_join(
  tibble(
    trace = c(z_mcmc),
    param = rep(colnames(z_mcmc), each = nrow(z_mcmc)),
    iter = rep(1:nrow(z_mcmc), length(colnames(z_mcmc))),
    obs_id = stringr::str_sub(
      param, 
      start = stringr::str_locate(param, pattern = "\\[")[,1] + 1,
      end = stringr::str_locate(param, pattern = "\\,")[,1] - 1
    ) %>% as.numeric(),
    dim = stringr::str_sub(
      param, 
      start = stringr::str_locate(param, pattern = "\\,")[,1] + 1,
      end = stringr::str_locate(param, pattern = "\\]")[,1] - 1
    ) %>% as.numeric()
  ),
  tibble(
    clus_id = c(samples_relabeled$clus_id),
    iter = rep(1:nrow(samples_relabeled$clus_id), length(colnames(samples_relabeled$clus_id))),
    obs_id = rep(1:ncol(samples_relabeled$clus_id), each = nrow(samples_relabeled$clus_id))
  ),
  by = c("iter", "obs_id")
)

# posterior probabilities on numbers of groups
clus_id <- lapply(fit, function(x) x[,which(grepl("clus_id", colnames(x)))])
clus_id_all <- do.call("rbind", clus_id)
ngroups_mcmc <- apply(clus_id_all, 1, function(x) length(unique(x)))
round(table(ngroups_mcmc) / length(ngroups_mcmc), 3)

z_tbl %>%
  group_by(obs_id, dim) %>%
  summarize(
    mean = mean(trace),
    clus = getmode(clus_id),
    clus_prob = mean(clus_id == clus)
  ) %>%
  pivot_wider(
    names_from = dim,
    values_from = mean, 
    names_prefix = "z"
  ) %>%
  ungroup() %>%
  mutate(
    clus_mode = factor(clus)
  ) %>% 
  mutate(
    obs_id = ifelse(obs_id > 7, obs_id + 1, obs_id)
  ) %>%
  ggplot() +
  geom_text(aes(x = z1, y = z2, col = clus_mode, label = obs_id)) +
  theme_bw() +
  guides(col = "none") +
  labs(x = bquote(z[1]), y = bquote(z[2]))
```

```{r}
distance <- function(x, method = "euclidean", func = func){
  if(method != "custom") {
    dist.vec <- parallelDist::parDist(x, method = method)
  } else{
    dist.vec <- parallelDist::parDist(x, method = method, func = func)
  }
  dist <- as.matrix(dist.vec)
  
  if(method == "custom") {
    dist <- dist / ncol(x)
    diag(dist) <- 1
  }
  
  return(dist)
}
pairwise_groups <- function(clus_id) {
  # house keeping
  nobs <- ncol(clus_id)
  nmcmc <- nrow(clus_id)
  
  same_group <- matrix(0, nobs, nobs)
  for(iter in 1:nmcmc){
    tmp <- as.matrix(distance(matrix(clus_id[iter,], ncol = 1)))
    tmp[tmp > 0] <- 1
    tmp <- -(tmp - 1)
    same_group <- same_group + tmp
  }
   return(same_group/nmcmc)
}

# example
ex_matrix <- t(sapply(1:100, function(x) sample(1:3, size = 10, replace = T)))
pairwise_groups(ex_matrix)
matchingFuncPtr <- RcppXPtrUtils::cppXPtr(
'double customDist(const arma::mat &A, const arma::mat &B) {
  return arma::accu(A == B);
}', depends = c("RcppArmadillo"))
distance(t(ex_matrix), method = "custom", func = matchingFuncPtr)

# data
clus_id <- samples_relabeled$clus_id
test2 <- distance(t(clus_id), method = "custom", func = matchingFuncPtr)

# by quadrats, but labeled by site
test <- test2
test[upper.tri(test)] <- NA
fields::image.plot(
  1:nrow(test), 
  1:ncol(test), 
  test,
  col = gray.colors(n=128,start=1,end=0), 
  breaks = seq(0,1,length=129),
  axes = F,
  xlab = "Site number",
  ylab = "Site number"
)
box()
axis(
  1, 
  at = 1:29, 
  labels = c(1:7, 9:30),
  cex.axis = .75
)
axis(
  2, 
  at = 1:29, 
  labels = c(1:7, 9:30),
  cex.axis = .75
)
```
