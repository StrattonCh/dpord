---
title: "Manuscript simulations"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
header-includes:
  - \usepackage{setspace}\doublespacing
  - \usepackage{mdframed, caption}
  - \usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
  - \usepackage{float}
  - \floatplacement{figure}{H} 
  - \usepackage{longtable}
  - \usepackage{blkarray, bigstrut}
  - \usepackage{booktabs}
  - \usepackage{multirow}
---

\newpage

```{r setup, include = F}
rm(list = ls())

library(knitr)
hook_chunk <- knitr::knit_hooks$get('chunk')
knit_hooks$set(chunk = function(x, options) {

  # add latex commands if chunk option singlespacing is TRUE
  if(isTRUE(options$singlespacing)){
    return(sprintf("\\singlespacing\n %s \n\\doublespacing", hook_chunk(x, options)))
  } else{
    return(hook_chunk(x, options))
  }
})
knitr::opts_chunk$set(
  fig.align = "center",
  tidy = T,
  singlespacing = TRUE,
  cache = FALSE,
  fig.dim = c(10,8),
  message = FALSE,
  warning = FALSE,
  comment = NA,
  echo = F
)

# packages
packs <- c("dplyr", "nimble", "htmltools", "ggplot2", "sf", "Rcpp", "RcppArmadillo", "inline", "mvtnorm", "readr", "parallel", "xtable", "rstan", "coda", "vegan", "tidyr", "stringr", "tidyverse", "plotly", "CommEcol", "cluster", "rstan")
sapply(packs, require, character.only = T)
rm(packs)

# convenience
`%notin%` <- Negate("%in%")
options(mc.cores = parallel::detectCores())
source("simulations/helpers.R")
```

```{r}

```

# Introduction

Simulations using COMPAS, similar to Hui.

# Compas example

Generates abundances, switch to presence-absence.

```{r, eval = F}
set.seed(02222023)
coords <- rbind(
  mvtnorm::rmvnorm(15, c(30, 60), 30*diag(2)),
  mvtnorm::rmvnorm(15, c(60, 40), 30*diag(2)),
  mvtnorm::rmvnorm(15, c(80, 60), 30*diag(2))
)
plot(coords, type = "n", main = "True latent coordinates")
text(coords, labels = 1:45, col = rep(1:3, each = 15))
mat <- compas(
  S = 30, 
  dims = 2,
  am = c(5, 5),
  beta.R = c(1, 1), 
  coords = coords, 
  n.quanti = 1,
  n.quali = 0.05, 
  add1 = 0.05
)
# mat[mat > 1] <- 1
mat <- mat[which(rowSums(mat) != 0),]
```

## NMDS

```{r, eval = F}
nmds <- vegan::metaMDS(
  mat,
  distance = "bray", 
  k = 3
)
plot(nmds$points)
```

## DPORD

```{r, eval = F}
library(gmp)
# probability mass function from Antoniak (1974)
antoniak <- function(k, alpha, n){
  alpha <- gmp::as.bigq(as.character(MASS::fractions(alpha)))
  
  # A.n first
  A.n <- function(x, n){
    sum(abs(gmp::Stirling1.all(n)) * x^(1:n))
  }
  
  # compute mass
  out <- as.numeric((abs(gmp::Stirling1(n, k)) * alpha^k) / A.n(alpha, n))
  return(out)
}
plot(sapply(1:10, function(x) antoniak(x, 1/1, 45)), main = "Prior mass on number of groups for n = 45, alpha = 1/2")
```

```{r, eval = F}
# model based 
code <- nimbleCode({
  # priors
  phi ~ dunif(0, 10)
  ## site effects
  for(site in 1:nsites){
    alpha[site] ~ dnorm(0, 1)
  }
  
  ## species effects
  for(species in 1:nspecies){
    beta[species] ~ dnorm(0, 1)
  }
  
  ## z priors
  ### Dirichlet process mixture parameters
  clus_id[1:nsites] ~ dCRP(dp_con, size = nsites)
  dp_con ~ dgamma(1, 2)
  
  ### table parameters - fix covariance as identity
  for(i in 1:max_clus){
    mu[i, 1:d] ~ dmnorm(mu0[1:d], Lambda0[1:d, 1:d])
  }
  
  for(site in 1:nsites){
    # identity matrix for constraint
    z[site, 1:d] ~ dmnorm(mu[clus_id[site], 1:d], cov = S[1:d, 1:d])
  }
  
  # theta prior
  ## upper triangle = 0
  for(row in 1:(d-1)){
    for(col in (row+1):d){
      theta[row, col] <- 0
    }
  }
  
  ## diag > 0
  for(diag_element in 1:d){
    theta[diag_element, diag_element] ~ T(dnorm(0, sd = 1), 0, Inf)
  }
  
  ## lower diag of first d rows
  for(row in 2:d){
    for(col in 1:(row-1)){
      theta[row, col] ~ dnorm(0, sd = 1)
    }
  }
  
  ## all other elements
  for(row in (d+1):nspecies){
    for(col in 1:d){
      theta[row, col] ~ dnorm(0, sd = 1)
    }
  }
  
  # likelihood 
  for(site in 1:nsites){
    for(species in 1:nspecies){
      log(lambda[site, species]) <- alpha[site] + beta[species] + inprod(z[site,1:d], theta[species, 1:d])
      nbp[site, species] <- phi / (phi + lambda[site, species])
      Y[site, species] ~ dnegbin(prob = nbp[site, species], size = phi)
    }
  }
})
init_func <- function(){
  d <- 2
  nrow <- 40
  nspecies <- 11
  max_clus <- 40 
  
  theta_init <- matrix(rnorm(d * nspecies), nspecies, d)
  diag(theta_init) <- abs(rnorm(d))
  theta_init[upper.tri(theta_init)] <- 0
  
  list(
    alpha = rnorm(nrow),
    beta = rnorm(nspecies),
    z = matrix(rnorm(nrow * d), nrow, d),
    theta = theta_init,
    dp_con = 1,
    clus_id = sample(c(1, 2), size = nrow, replace = T),
    mu = matrix(rnorm(d*max_clus), max_clus, d),
    phi = 1
  )
}

this_cluster <- makeCluster(3)
fit <- parLapply(
  cl = this_cluster,
  X = 1001:1003,
  fun = fit_model,
  code = code,
  data = list(
    Y = mat,
    S = diag(2),
    mu0 = rep(0, 2),
    Lambda0 = diag(2),
    one = rep(1, 2)
  ),
  constants = list(
    nsites = nrow(mat),
    nspecies = ncol(mat),
    d = 2,
    max_clus = 40
  ),
  inits = init_func,
  niter = 75000,
  burnin = 25000,
  nchains = 1,
  thin = 5
)
stopCluster(this_cluster)
```

```{r, eval = F}
source("coral.R")
coral.fit <- fit.coral(y = mat, family = "negative.binomial", num.lv = 2, num.clus = 3, site.eff = TRUE, save.model = F)

plot(coral.fit$lv.mean, type = "n")
text(coral.fit$lv.mean, labels = 1:45, col = coral.fit$clus.modal)
```

```{r, eval = F}
fit_ <- fit
# fit <- lapply(fit, function(x) x[(nrow(x)/2 + 1):nrow(x), ])
samples_relabeled <- ord_ls(mcmc = fit[c(1:3)], d = 2, seed = 02222023)

# traceplots
mu_tbl <- tibble(
  trace = c(samples_relabeled$mu),
  param = rep(colnames(samples_relabeled$mu), each = nrow(samples_relabeled$mu)),
  iter = rep(1:nrow(samples_relabeled$mu), length(colnames(samples_relabeled$mu))),
  chain = 1,
  clus_id = stringr::str_sub(param, 4, 4), 
  dim = stringr::str_sub(param, 7, 7)
)
mu_tbl %>%
  filter(dim == 1) %>%
  ggplot(aes(x = iter, y = trace, col = clus_id)) +
  # facet_wrap(~ chain, labeller = label_both) +
  geom_line() +
  theme_bw() +
  labs(
    title = bquote("Traceplot for" ~ mu[1] * ", adjusted for label switching")
  )
mu_tbl %>%
  filter(dim == 2) %>%
  ggplot(aes(x = iter, y = trace, col = clus_id)) +
  # facet_wrap(~ chain, labeller = label_both) +
  geom_line() +
  theme_bw() +
  labs(
    title = bquote("Traceplot for" ~ mu[2] * ", adjusted for label switching")
  )

# plot lvs
z_mcmc <- samples_relabeled$other[,which(grepl("z", colnames(samples_relabeled$other)))]
z_tbl <- left_join(
  tibble(
    trace = c(z_mcmc),
    param = rep(colnames(z_mcmc), each = nrow(z_mcmc)),
    iter = rep(1:nrow(z_mcmc), length(colnames(z_mcmc))),
    obs_id = stringr::str_sub(
      param, 
      start = stringr::str_locate(param, pattern = "\\[")[,1] + 1,
      end = stringr::str_locate(param, pattern = "\\,")[,1] - 1
    ) %>% as.numeric(),
    dim = stringr::str_sub(
      param, 
      start = stringr::str_locate(param, pattern = "\\,")[,1] + 1,
      end = stringr::str_locate(param, pattern = "\\]")[,1] - 1
    ) %>% as.numeric()
  ),
  tibble(
    clus_id = c(samples_relabeled$clus_id),
    iter = rep(1:nrow(samples_relabeled$clus_id), length(colnames(samples_relabeled$clus_id))),
    obs_id = rep(1:ncol(samples_relabeled$clus_id), each = nrow(samples_relabeled$clus_id))
  ),
  by = c("iter", "obs_id")
)

clus_id <- lapply(fit, function(x) x[,which(grepl("clus_id", colnames(x)))])
clus_id_all <- do.call("rbind", clus_id)
ngroups_mcmc <- apply(clus_id_all, 1, function(x) length(unique(x)))
round(table(ngroups_mcmc) / length(ngroups_mcmc), 3)

z_tbl %>%
  group_by(obs_id, dim) %>%
  summarize(
    mean = mean(trace),
    clus = getmode(clus_id),
    clus_prob = mean(clus_id == clus)
  ) %>%
  pivot_wider(
    names_from = dim,
    values_from = mean, 
    names_prefix = "z"
  ) %>%
  ungroup() %>%
  mutate(
    cluster = factor(clus)
  ) %>% 
  mutate(
    obs_id = ifelse(obs_id > 7, obs_id + 1, obs_id)
  ) %>%
  ggplot() +
  geom_text(aes(x = z1, y = z2, col = cluster, label = obs_id)) +
  theme_bw() +
  # guides(col = "none") +
  labs(x = bquote(z[1]), y = bquote(z[2]))
```

# Simulation

```{r}
rm(list = ls())
source("simulations/helpers.R")
source("coral.R")
```

## Simulation parameters

We will compare DPORD with the methods discussed in Hui et al (2017) when the number of clusters in the latent space is unknown. In total, these methods include:

- DPORD
- CORAL with DICc
- RPD with AICc
- Ward clustering, maximizing average silhouette width
- PAM with Bray-Curtis
- K-means, maximizing Calinkski-Harabasz index
- K-means, maximizing simple structure indices

For all methods but DPORD, candidate clusters from K = 2 to 10 will be considered. We will generate 100 data sets using COMPAS, considering 2, 3, 4, and 5 clusters in the latent space. 

### COMPAS parameters

COMPAS requires coordinates of true site ordinations on a grid between 0 and 100, and specification of various mean abundances and sources of variation. 

```{r, fig.dim = c(8, 10)}
compas_params <- list(
  k2 = list(
    mu = rbind(c(30, 60), c(60, 40)),
    sigma = rep(40, 2)
  ),
  k3 = list(
    mu = rbind(c(30, 30), c(70, 40), c(50, 70)),
    sigma = rep(40, 3)
  ),
  k4 = list(
    mu = rbind(c(30, 30), c(30,70), c(70,70), c(70,30)),
    sigma = rep(40, 4)
  ),
  k5 = list(
    mu = rbind(c(20, 20), c(20,80), c(80,80), c(80,20), c(50, 50)),
    sigma = rep(40, 5)
  )
)

# plot
plot_grid <- expand.grid(x = seq(0, 100, length.out = 100), y = seq(0, 100, length.out = 100))
plot_true_and_realizations(plot_grid, compas_params, ndx = 1)
plot_true_and_realizations(plot_grid, compas_params, ndx = 2)
plot_true_and_realizations(plot_grid, compas_params, ndx = 3)
plot_true_and_realizations(plot_grid, compas_params, ndx = 4)
```

```{r, eval = F}
set.seed(02232023)
compas_data <- list()

# k2
compas_data[[1]] <- lapply(
  1:100,
  function(x){
    set.seed(x);
    coords_ = rbind(
      mvtnorm::rmvnorm(15, compas_params$k2$mu[1,], compas_params$k2$sigma[1]*diag(2)),
      mvtnorm::rmvnorm(15, compas_params$k2$mu[2,], compas_params$k2$sigma[2]*diag(2))
    );
    list(
      true_coords = coords_, 
      Y =     compas(
        S = 50, 
        dims = 2,
        am = c(5, 5),
        beta.R = c(1, 1), 
        coords = coords_, 
        n.quanti = 1,
        n.quali = 0.05, 
        add1 = 0.05
      )
    )
    
  }
)

# k3
compas_data[[2]] <- lapply(
  1:100,
  function(x){
    set.seed(x);
    coords_ <- rbind(
        mvtnorm::rmvnorm(15, compas_params$k3$mu[1,], compas_params$k3$sigma[1]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k3$mu[2,], compas_params$k3$sigma[2]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k3$mu[3,], compas_params$k3$sigma[3]*diag(2))
      );
    list(
      true_coords = coords_, 
      Y =     compas(
        S = 50, 
        dims = 2,
        am = c(5, 5),
        beta.R = c(1, 1), 
        coords = coords_, 
        n.quanti = 1,
        n.quali = 0.05, 
        add1 = 0.05
      )
    )
  }
)

# k4
compas_data[[3]] <- lapply(
  1:100,
  function(x){
    set.seed(x);
    coords_ <- rbind(
        mvtnorm::rmvnorm(15, compas_params$k4$mu[1,], compas_params$k4$sigma[1]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k4$mu[2,], compas_params$k4$sigma[2]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k4$mu[3,], compas_params$k4$sigma[3]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k4$mu[4,], compas_params$k4$sigma[4]*diag(2))
      );
    list(
      true_coords = coords_, 
      Y =     compas(
        S = 50, 
        dims = 2,
        am = c(5, 5),
        beta.R = c(1, 1), 
        coords = coords_, 
        n.quanti = 1,
        n.quali = 0.05, 
        add1 = 0.05
      )
    )
  }
)


# k5
compas_data[[4]] <- lapply(
  1:100,
  function(x){
    set.seed(x);
    coords_ <- rbind(
        mvtnorm::rmvnorm(15, compas_params$k5$mu[1,], compas_params$k5$sigma[1]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k5$mu[2,], compas_params$k5$sigma[2]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k5$mu[3,], compas_params$k5$sigma[3]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k5$mu[4,], compas_params$k5$sigma[4]*diag(2)),
        mvtnorm::rmvnorm(15, compas_params$k5$mu[5,], compas_params$k5$sigma[5]*diag(2))
      )
    list(
      true_coords = coords_, 
      Y =     compas(
        S = 50, 
        dims = 2,
        am = c(5, 5),
        beta.R = c(1, 1), 
        coords = coords_, 
        n.quanti = 1,
        n.quali = 0.05, 
        add1 = 0.05
      )
    )
  }
)
saveRDS(compas_data, file = "simulations/compas_data.rds")
```

```{r}
compas_data <- readRDS("simulations/compas_data.rds")
```

```{r}
mat = compas_data[[1]][[1]]$Y
true_coords = compas_data[[1]][[1]]$true_coords
k = 2
sim = 1
niter = 10000
nburnin = 5000
thin = 5
nchains = 3
max_clus = 3
max_attempts = 2


one_sim(
  mat = compas_data[[1]][[1]]$Y,
  true_coords = compas_data[[1]][[1]]$true_coords,
  k = 2, 
  sim = 1, 
  niter = 100000,
  nchains = 3,
  nburnin = 50000,
  thin = 5,
  max_clus = 8,
  max_attempts = 10
)
```



